# Matchup Constraints Implementation

## Overview

Task 6 from the NBA Prediction System spec has been successfully implemented. This task adds the `MatchupConstraintBuilder` class to convert opponent defensive schemes and player roles into geometric halfspace constraints for capability region construction.

## Files Created/Modified

### New Files
- `src/regions/matchup.py` - Main implementation of MatchupConstraintBuilder
- `examples/matchup_constraints_demo.py` - Demonstration script
- `docs/matchup_constraints_implementation.md` - This documentation

### Modified Files
- `src/regions/__init__.py` - Added exports for MatchupConstraintBuilder
- `tests/test_regions.py` - Added 15 comprehensive unit tests

## Implementation Details

### MatchupConstraintBuilder Class

The `MatchupConstraintBuilder` class provides three main methods:

#### 1. `scheme_to_constraints(opponent_row, toggles=None)`

Converts opponent defensive scheme parameters into halfspace constraints:

- **Blitz Constraint**: High blitz rate constrains usage and increases turnover risk
  - Formula: `usage + 2.0 * tov_pct <= baseline * (1 + blitz_penalty)`
  
- **Rim Deterrence Constraint**: Strong rim protection limits rim attempts
  - Formula: `rim_attempt_rate <= baseline * (2.0 - rim_deterrence)`
  
- **Defensive Rebounding Constraint**: Strong defensive rebounding limits offensive rebounds
  - Formula: `orb_pct <= baseline * (2.0 - def_reb_strength)`
  
- **Foul Discipline Constraint**: Good foul discipline reduces free throw opportunities
  - Formula: `ft_rate <= baseline * (2.0 - foul_discipline)`
  
- **Switch Constraint**: High switch rate affects isolation and assist opportunities
  - Formula: `usage - ast_pct <= baseline_diff * (1 + switch_penalty)`
  
- **Help Defense Constraint**: High help frequency constrains assist opportunities
  - Formula: `ast_pct <= baseline * (1.5 - help_nail_freq)`

Each constraint can be individually toggled on/off via the `toggles` parameter.

#### 2. `role_bounds(role, attribute_bounds=None)`

Generates role-specific attribute bounds as halfspace constraints:

- **Starter**: Higher usage floor (0.18-0.40), tighter ranges
- **Rotation**: Moderate ranges (usage 0.12-0.35)
- **Bench**: Lower usage ceiling (0.08-0.30), wider variance

Custom bounds can be provided via the `attribute_bounds` parameter.

#### 3. `pairwise_frontiers_for(player_role, opponent_scheme_bin, frontier_pairs=None)`

Retrieves pre-fitted frontier models that define trade-off boundaries:

- Default frontier pairs:
  - `(usage, ts_pct)` - Volume-efficiency tradeoff
  - `(usage, tov_pct)` - Volume-turnover tradeoff
  - `(ast_pct, tov_pct)` - Playmaking-turnover tradeoff
  - `(three_pa_rate, ts_pct)` - 3PT volume-efficiency tradeoff
  - `(rim_attempt_rate, ts_pct)` - Rim volume-efficiency tradeoff

Gracefully handles missing frontier files by returning an empty list.

#### 4. `build_all_constraints(...)` (Convenience Method)

Combines all three methods into a single call, returning:
- List of FrontierModel objects
- List of scheme constraint Halfspaces
- List of role bound Halfspaces

## Attribute Space

The implementation uses an 11-dimensional attribute space:

1. `ts_pct` - True shooting percentage
2. `usage` - Usage rate
3. `ast_pct` - Assist percentage
4. `tov_pct` - Turnover percentage
5. `orb_pct` - Offensive rebound percentage
6. `drb_pct` - Defensive rebound percentage
7. `stl_pct` - Steal percentage
8. `blk_pct` - Block percentage
9. `three_pa_rate` - Three-point attempt rate
10. `rim_attempt_rate` - Rim attempt rate
11. `ft_rate` - Free throw rate

## Integration with RegionBuilder

The constraints generated by `MatchupConstraintBuilder` integrate seamlessly with the existing `RegionBuilder`:

```python
# Build constraints
matchup_builder = MatchupConstraintBuilder()
frontiers, scheme_constraints, role_constraints = matchup_builder.build_all_constraints(
    player_role='starter',
    opponent_row=opponent_data,
    opponent_scheme_bin='high_blitz'
)

# Use with RegionBuilder
region_builder = RegionBuilder()
polytope = region_builder.assemble_halfspaces(
    frontiers=frontiers,
    scheme_constraints=scheme_constraints,
    role_bounds=role_constraints
)
```

## Testing

Comprehensive test suite with 15 unit tests covering:

- Initialization and configuration
- Scheme constraint generation (basic, blitz, rim deterrence)
- Constraint toggles
- Role bounds (starter, rotation, bench, custom)
- Frontier loading (missing files, custom pairs)
- Full constraint building
- Dimension matching and validation
- Halfspace validity

All tests pass successfully.

## Demo Script

The `examples/matchup_constraints_demo.py` script demonstrates:

1. Creating opponent defensive scheme data
2. Initializing MatchupConstraintBuilder
3. Generating scheme constraints
4. Generating role bounds
5. Loading frontier models
6. Building complete constraint set
7. Creating capability region
8. Verifying constraints
9. Analyzing constraint impact

Run with: `python examples/matchup_constraints_demo.py`

## Requirements Satisfied

This implementation satisfies all requirements from Requirement 5:

- ✅ 5.1: Convert opponent scheme parameters to halfspace constraints
- ✅ 5.2: Apply role-specific attribute bounds
- ✅ 5.3: Retrieve pairwise frontier constraints
- ✅ 5.4: Return list of halfspace constraints for region construction

## Next Steps

The next task in the implementation plan is:

**Task 7: Implement global simulator**
- Create `src/simulation/global_sim.py` with GlobalSimulator class
- Define GameState enum
- Implement sampling and state transition logic
- Implement box stat projection

This will build on the capability regions created using the matchup constraints.
